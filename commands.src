import_code("./jumpfile/jumpfile-text.src")
import_code("./utils/random-ip.src")
import_code("./managers/command/command.src")
import_code("./managers/session/session.src")

libs = {}
libs.corruptLog = function(fileObject) //overwrite system.log by copy the smallest file to that dir
    while fileObject.parent
        fileObject = fileObject.parent
    end while
    files = self.allFiles(fileObject, 3)
    toCopy = null
    for file in files
        if file.is_folder or (not file.has_permission("r")) then continue
        if not toCopy then toCopy = file
        if val(file.size) < val(toCopy.size) then toCopy = file
    end for
    if not toCopy then return print("No file to overwrite log! try using ""touch"".")
    logFile = self.getFile("/var/system.log", fileObject)
    if not logFile then print("log file not found!")
    tryDelete = logFile.delete
    if tryDelete == "" then print("Log file deleted.") else return print("Error: " + tryDelete)
    tryCopy = toCopy.copy("/var", "system.log")
    if tryCopy == true then return true
    return print(tryCopy)
end function
libs.getFile = function(toPath, fileObject) //changeDir only support folder but this works for both
    if not fileObject then fileObject = globals.current.folder
    while fileObject.parent
        fileObject = fileObject.parent
    end while
    if toPath.len == 0 then return print("File not found.")
    while (toPath.len > 1) and (toPath[-1] == "/") //trim end "/"
        toPath = toPath[:-1]
    end while
    while (toPath.len > 1) and (toPath[0] == "/") //trim start "/"
        toPath = toPath[1:]
    end while
    if toPath == "/" then return fileObject
    toPath = toPath.split("/")
    for i in toPath.indexes
        found = false
        if i == (toPath.len - 1) then
            for f in fileObject.get_folders + fileObject.get_files
                if not f.name == toPath[i] then continue
                return f
            end for
            return print("File not found")
        end if
        for f in fileObject.get_folders
            if not f.name == toPath[i] then continue
            found = true
            fileObject = f
            break
        end for
        if not found then return print("File not found.")
    end for
    return fileObject
end function
libs.allFiles = function(fileObject, maxDepth = -1)//find all files in a computer usinf fileObject (fileObject)
    fileObject = libs.toFile(fileObject)
    if fileObject.is_folder then total = {"ret":[fileObject], "stack":[maxDepth, fileObject]} else return [fileObject]
    while total.stack
        c = {"folder":total.stack.pop, "maxDepth":total.stack.pop}
        if c.maxDepth then total.ret = total.ret + c.folder.get_folders + c.folder.get_files else continue
        folders = c.folder.get_folders
        for i in range(len(folders) - 1)
            if folders then [total.stack.push(c.maxDepth - 1), total.stack.push(folders[i])] else break
        end for
    end while
    return total.ret
end function
libs.typeofFile = function(fileObject)//return file type "txt" "fld" "bin" else "null"
    if not typeof(fileObject) == "file" then return null
    if fileObject.is_folder then return "fld"
    if fileObject.is_binary then return "bin"
    return "txt"
end function
libs.toFile = function(anyObject)//converts any Object to "Parent fileType object" ("/")
    if typeof(anyObject) == "shell" then return anyObject.host_computer.File("/")
    if typeof(anyObject) == "computer" then return anyObject.File("/")
    if typeof(anyObject) == "file" then
        while anyObject.parent
            anyObject = anyObject.parent
        end while
        return anyObject
    end if
    return anyObject
end function
libs.fileSize = function(bytes) //translate byte to kb and mb
    bytes = bytes.to_int
    i = 0
    units = ["B","KB","MB","GB","TB","PT"]
    while bytes > 1024
        bytes = bytes / 1024
        i = i + 1
    end while
    return round(bytes, 2) + units[i]
end function
libs.checkPermission = function(file)
    permissions = ["-", "-", "-"]
    if file.has_permission("r") then
        permissions[0] = "r"
    end if
    if file.has_permission("w") then
        permissions[1] = "w"
    end if
    if file.has_permission("x") then
        permissions[2] = "x"
    end if
    return permissions.join("")
end function
libs.find = function(fileName, fileObject) //find files under a dir
    founded = []
    files = libs.allFiles(fileObject)
    for file in files
        if lower(file.name).indexOf(lower(fileName)) != null then founded = founded + [file]
    end for
    return founded
end function

clacCommandHandler = function(params, extensionMediator)
    help = "calc: num sign num2 [eg 2 + 2] + - * / %"
    calc = user_input("Enter : ")
    calc = calc.split(" ")
    if(calc.len != 3)then return print(help)
    if(calc[1] == "-")then
        return print((calc[0]).to_int - (calc[2]).to_int)
    end if
    if(calc[1] == "+")then
        return print((calc[0]).to_int + (calc[2]).to_int)
    end if
    if(calc[1] == "*")then
        return print((calc[0]).to_int * (calc[2]).to_int)
    end if
    if(calc[1] == "/")then
        return print((calc[0]).to_int / (calc[2]).to_int)
    end if
    if(calc[1] == "%")then
        return print((calc[0]).to_int % (calc[2]).to_int)
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "calc",
    "description": "Built in calculator",
    "parameters": [],
    "callback": @clacCommandHandler,
    "permissions": {
        "object": "file"
    }
}))
findfileCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fileObject = handler.current.file
    fileName = params.filename
    foundFiles = libs.find(fileName,fileObject)
    output = "TYPE +WRX PATH PERMISSIONS SIZE"
    if not foundFiles then return print("No filenames found.")
    for file in foundFiles
        output = output + "\n" + libs.typeofFile(file) + " " + libs.checkPermission(file) + " " + file.path + " " + file.permissions + " " + libs.fileSize(file.size)
    end for
    return print(format_columns(output))
end function
commandManager.registerCommand(Command.New({
    "name": "find",
    "description": "Search for file by its name",
    "parameters": [
        Parameter.New({
        "name": "filename",
        "required": true
    })],
    "callback": @findfileCommandHandler,
    "permissions": {
        "object": "file"
    }
}))
vulnCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fileObject = handler.current.file
    allFiles = libs.allFiles(fileObject)
    perm = params.permission
    output = "TYPE PATH FILE_PERM USER_PERM SIZE"
    for file in allFiles
        if(perm == "x")then
            if(libs.typeofFile(file)!= "bin")then continue
        end if
        if(perm == "r")then
            if(libs.typeofFile(file)!= "txt")then continue
        end if
        if(not file.has_permission(perm))then continue
        userPermission = libs.checkPermission(file)
        output = output+ "\n" + libs.typeofFile(file) + " " + file.path + " " + file.permissions + " " + userPermission + " " + libs.fileSize(file.size)
    end for
    return print(format_columns(output))
end function
commandManager.registerCommand(Command.New({
    "name": "vuln",
    "description": "Get vulnerable File / Folder Permissions. params [r] [x] [w]",
    "parameters": [
        Parameter.New({
        "name": "permission",
        "required": false,
        "default": "r"
    })],
    "callback": @vulnCommandHandler,
    "permissions": {
        "object": "file"
    }
}))

hashdumpCommandHandler = function(params,extensionMediator)
    nametoFind = ["Mail.txt","Bank.txt","passwd"]//target file scope
    libMannager = extensionMediator.getExtension("libManager")
    lib = libMannager.getCurrentLib("crypto")
    if lib == null then return Error.New("No crypto library loaded")
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fileName = params.fileName
    rootOnly = false
    if(fileName=="mail")then 
        fileName = "Mail.txt"
    else if(fileName=="bank")then
        fileName = "Bank.txt"
    else if(fileName=="passwd")then
        fileName = "passwd"
    else if(fileName=="root")then
        fileName = "passwd"
        rootOnly = true
    end if
    found = false
    anyfileFound = false
    denied = "Can't-Read-file"
    noContent = "No-Content-In-file"
    foundFiles = "PATH PERMISSIONS"
    fileObject = handler.current.file
    allFiles = libs.allFiles(fileObject,9)
    output = "PATH USERNAME PASSWORD PERMISSIONS"
    for file in allFiles
        if(not libs.typeofFile(file) == "txt") then continue
        for f in nametoFind
            if(not fileName == "all")then
                if(not f == fileName)then continue
            end if
            if(not file.name == f) then continue                               //check file in target scope
            anyfileFound = true      
            foundFiles = foundFiles+"\n"+file.path+" "+file.permissions
            if(not file.has_permission("r")) then
                output = output +"\n"+ file.path + " " + denied + " " + denied + " " + file.permissions
                found = true
                continue
            end if
            if(rootOnly==true)then
                fileList = file.get_content.split("\n")[0]
                userName = fileList.split(":")[0]
                hash = fileList.split(":")[1]
                password = lib.lib.decipher(hash)
                output = output +"\n"+ file.path + " " + userName + " " + password + " " + file.permissions
                found = true
                return print(format_columns(output))
            else
                fileList = file.get_content.split("\n")
            end if
            for hashList in fileList
                if hashList == "" then
                    output = output +"\n"+ file.path + " " + noContent + " " + noContent + " " + file.permissions
                    continue
                end if
                userName = hashList.split(":")[0]
                hash = hashList.split(":")[1]
                password = lib.lib.decipher(hash)
                output = output +"\n"+ file.path + " " + userName + " " + password + " " + file.permissions
                found = true
            end for
        end for
    end for
    if(found == true)then return print(format_columns(output))
    if(anyfileFound == false)then return print("No file found on the system.")
    return print("Permission denied.\n"+format_columns(foundFiles))
end function
commandManager.registerCommand(Command.New({
    "name": "hashdump",
    "description": "Get all passwords in the computer. fileName [mail] [bank] [root] [passwd] [all (default)]",
    "parameters": [
        Parameter.New({
            "name": "fileName",
            "required": false,
            "default": "all"
        })
    ],
    "callback": @hashdumpCommandHandler
}))

hashrawCommandHandler = function(params, extensionMediator)
    nametoFind = ["Mail.txt","Bank.txt","passwd"]//target file scope
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fileObject = handler.current.file
    allFiles = libs.allFiles(fileObject,9)
    denied = "Can't-Read-file"
    noContent = "Nothing-Found-In-file"
    output = "PATH USERNAME HASH PERMISSIONS SIZE"
    anyhashFound = false
    for file in allFiles
        if(not libs.typeofFile(file) == "txt") then continue
        for fname in nametoFind
            if(not file.name == fname) then continue
            anyhashFound = true
            if(not file.has_permission("r")) then
                output = output + "\n" + file.path + " " + denied + " " + denied + " " + file.permissions + " " + libs.fileSize(file.size)
                continue
            end if
            fileContent = file.get_content
            if(fileContent==" ")then
                output = output + "\n" + file.path + " " + noContent + " " + noContent + " " + file.permissions + " " + libs.fileSize(file.size)
                continue
            end if
            if(not fileContent)then
                output = output + "\n" + file.path + " " + noContent + " " + noContent + " " + file.permissions + " " + libs.fileSize(file.size)
                continue
            end if
            splitContent = fileContent.split("\n")
            for creds in splitContent
                if(not creds)then continue
                if(creds==" ")then continue
                passHash = creds.split(":")[1]
                if(not passHash.len == 32)then continue
                username = creds.split(":")[0]
                output = output + "\n" + file.path + " " + username + " " + passHash + " " + file.permissions + " " + libs.fileSize(file.size)
            end for
        end for
    end for
    if(anyhashFound)then return print(format_columns(output))
    return print("No file found.\nCheck permissions..")
end function
commandManager.registerCommand(Command.New({
    "name": "hashraw",
    "description": "Get all accessible hashes in the computer.",
    "parameters": [],
    "callback": @hashrawCommandHandler
}))


lsCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    file = handler.getFile(path)
    if file isa Error then return file
    if file.children isa Error then return file.children

    viperUi.ls(file.children)
end function
commandManager.registerCommand(Command.New({
    "name": "ls",
    "description": "List all items in the provided directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": false,
            "default": "."
        })
    ],
    "callback": @lsCommandHandler
}))

fsCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    file = handler.getFile(path)
    if file isa Error then return file
    viperUi.fileSystem(file)
end function
commandManager.registerCommand(Command.New({
    "name": "fs",
    "description": "Display file system information",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": false,
            "default": "/"
        })
    ],
    "callback": @fsCommandHandler
}))

cdCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    return handler.goTo(path)
end function
commandManager.registerCommand(Command.New({
    "name": "cd",
    "description": "Change directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        })
    ],
    "callback": @cdCommandHandler
}))

chmodCommandHandler = function (params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fpath = params.fpath
    perms = params.perms
    recursive = params.recursive

    return handler.setPermissions(fpath, perms, recursive)
end function
commandManager.registerCommand(Command.New({
    "name": "chmod",
    "description": "Chmods a file or directory.",
    "parameters": [
        FlagParameter.New({
        "name": "recursive",
        "required": false,
        "default": "",
            "flag": "-R"
        }),
        Parameter.New({
            "name": "perms",
            "required": true
        }),
        Parameter.New({
            "name": "fpath",
            "required": true
        })
    ],
    "callback": @chmodCommandHandler
}))

chownCommandHandler = function (params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fpath = params.fpath
    newOwner = params.newOwner
    recursive = params.recursive
    
    return handler.setOwner(fpath, newOwner, recursive)
end function
commandManager.registerCommand(Command.New({
    "name": "chown",
    "description": "Changes the owner of a file or directory.",
    "parameters": [
        FlagParameter.New({
        "name": "recursive",
        "required": false,
        "default": "",
            "flag": "-R"
        }),
        Parameter.New({
            "name": "newOwner",
            "required": true
        }),
        Parameter.New({
            "name": "fpath",
            "required": true
        })
    ],
    "callback": @chownCommandHandler
}))

chgrpCommandHandler = function (params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    fpath = params.fpath
    newGroup = params.newGroup
    recursive = params.recursive
    
    return handler.setGroup(fpath, newGroup, recursive)
end function
commandManager.registerCommand(Command.New({
    "name": "chgrp",
    "description": "Changes the group of a file or directory.",
    "parameters": [
        FlagParameter.New({
        "name": "recursive",
        "required": false,
        "default": "",
            "flag": "-R"
        }),
        Parameter.New({
            "name": "newGroup",
            "required": true
        }),
        Parameter.New({
            "name": "fpath",
            "required": true
        })
    ],
    "callback": @chgrpCommandHandler
}))

mvCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path
    newPath = params.newPath

    return handler.move(path, newPath)
end function
commandManager.registerCommand(Command.New({
    "name": "mv",
    "description": "Move a file or directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        }),
        Parameter.New({
            "name": "newPath",
            "required": true
        })
    ],
    "callback": @mvCommandHandler
}))

writeCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path
    type = params.type
    content = params.content

    file = handler.getFile(path)
    if file isa Error then return file

    if type == ">" then
        file.setContent(content)
    else
        file.appendContent(content)
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "write",
    "description": "Write to a file",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        }),
        OptionsParameter.New({
            "name": "type",
            "required": true,
            "options": {
                ">": ">",
                ">>": ">>"
            }
        }),
        RestParameter.New({
            "name": "content",
            "required": false,
            "default": ""
        })
    ],
    "callback": @writeCommandHandler
}))


corruptLogsCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    file = handler.current.file
    if(handler.type == "file") then
        loglibFile = libs.getFile("/var/system.log",file)
        corruptLogs = libs.corruptLog(loglibFile)
        if(corruptLogs==true)then
            return print("Done.")
        else
            return print("Failed.")
        end if
    end if
    logFile = handler.getFile("/var/system.log")
    if logFile isa Error then return Error.New("Failed to get log file")
    handler.createFile("/var/t")
    tFile = handler.getFile("/var/t")
    if tFile isa Error then return Error.New("Failed to verify. Check permissions")
    handler.move("/var/t", "/var/system.log")
    return "Corrupted logs"
end function
commandManager.registerCommand(Command.New({
    "name": "clog",
    "description": "Corrupt the logs (best with root access)try your luck.",
    "parameters": [],
    "callback": @corruptLogsCommandHandler,
    "permissions": {
        "object": "file",
        "privilege": "guest"
    }
}))
commandManager.registerCommand(Command.New({
    "name": "corruptlogs",
    "description": "Corrupt the logs (best with root access)try your luck.",
    "parameters": [],
    "callback": @corruptLogsCommandHandler,
    "permissions": {
        "object": "file",
        "privilege": "guest"
    }
}))

cpCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path
    newPath = params.newPath

    return handler.copy(path, newPath)
end function
commandManager.registerCommand(Command.New({
    "name": "cp",
    "description": "Copy a file or directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        }),
        Parameter.New({
            "name": "newPath",
            "required": true
        })
    ],
    "callback": @cpCommandHandler
}))

catCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    file = handler.getFile(path)

    if file isa Error then return print(file.message)
    return file.content
end function
commandManager.registerCommand(Command.New({
    "name": "cat",
    "description": "Print the contents of a file",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        })
    ],
    "callback": @catCommandHandler
}))

touchCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    return handler.createFile(path)
end function
commandManager.registerCommand(Command.New({
    "name": "touch",
    "description": "Create a file",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        })
    ],
    "callback": @touchCommandHandler,
    "permissions": {
        "object": "computer"
    }
}))

mkdirCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    return handler.createFolder(path)
end function
commandManager.registerCommand(Command.New({
    "name": "mkdir",
    "description": "Create a directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        })
    ],
    "callback": @mkdirCommandHandler,
    "permissions": {
        "object": "computer"
    }
}))

rmCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path

    return handler.delete(path)
end function
commandManager.registerCommand(Command.New({
    "name": "rm",
    "description": "Delete a file or directory",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        })
    ],
    "callback": @rmCommandHandler
}))

crackCommandHandler = function(params, extensionMediator)
    libMannager = extensionMediator.getExtension("libManager")
    lib = libMannager.getCurrentLib("crypto")
    if lib == null then return Error.New("No crypto library loaded")

    hash = params.hash
    result = lib.lib.decipher(hash)
    return result
end function
commandManager.registerCommand(Command.New({
    "name": "crack",
    "description": "Crack a hash",
    "parameters": [
        Parameter.New({
            "name": "hash",
            "required": true
        })
    ],
    "callback": @crackCommandHandler
}))

nmapCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    ip = params.ip

    if ip == "random" then ip = randomIp()

    router = Router.New(ip)
    if router isa Error then return router
    devices = router.devices()

    allPorts = []
    handleAddDevice = function(device)
        if device.value.len == 0 then allPorts.push({"port": "none", "open": false, "forwarded": false, "local": device.key, "type": "none", "version": "none"})
        for port in device.value
            allPorts.push(port)
        end for
    end function
    forEach(devices, @handleAddDevice)

    allPorts.sort("port")

    viperUi.nmap(allPorts, router)
end function
commandManager.registerCommand(Command.New({
    "name": "nmap",
    "description": "Scan the network for devices",
    "parameters": [
        OptionsParameter.New({
            "name": "ip",
            "required": false,
            "options": {
                "ip": "ip",
                "random": "random"
            },
            "default": "random"
        })
    ],
    "callback": @nmapCommandHandler
}))

whoisCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    ip = params.ip

    adminInfo = whois(ip)
    infoLines = adminInfo.split(char(10))

    infoObject = {}
    infoObject.domainName = infoLines[0].split(":")[1].trim
    infoObject.adminContact = infoLines[1].split(":")[1].trim
    infoObject.email = infoLines[2].split(":")[1].trim
    infoObject.phone = infoLines[3].split(":")[1].trim

    viperUi.whois(infoObject)
end function
commandManager.registerCommand(Command.New({
    "name": "whois",
    "description": "Get information about an IP",
    "parameters": [
        Parameter.New({
            "name": "ip",
            "required": true
        })
    ],
    "callback": @whoisCommandHandler
}))

sshCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler

    ip = params.ip
    username = params.username
    password = params.password
    port = params.port
    service = params.service

    if password == "dict" then
        dictionaryManager = extensionMediator.getExtension("dictionaryManager")
        print "Trying dictionary attack"
        password = dictionaryManager.get()
        while not password isa Error 
            result = handler.connectTo(ip, port, username, password, service)
            if typeof(result)=="shell" then print("Password found "+username+"@"+password+".")
            if not result isa Error then break
            password = dictionaryManager.get()
        end while
    else
        result = handler.connectTo(ip, port, username, password, service)
    end if
    if result isa Error then return result
    session = sessionManager.addSession(result, {})
    sessionManager.setCurrentSession(sessionManager.getSessionIndex(session))
end function
commandManager.registerCommand(Command.New({
    "name": "ssh",
    "description": "Login to a computer",
    "parameters": [
        Parameter.New({
            "name": "ip",
            "required": true
        }),
        Parameter.New({
            "name": "username",
            "required": false,
            "default": "root"
        }),
        Parameter.New({
            "name": "password",
            "required": false,
            "options": {
                "dict": "dict",
            },
            "default": "dict"
        }),
        Parameter.New({
            "name": "port",
            "required": false,
            "type": PARAMETER_TYPES.NUMBER,
            "default": 22
        }),
        OptionsParameter.New({
            "name": "service",
            "required": false,
            "options": {
                "ssh": "ssh",
                "ftp": "ftp",
            },
            "default": "ssh"
        })
    ],
    "callback": @sshCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

passwdCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    username = params.username
    password = params.password

    result = handler.setPassword(username, password)
    if result isa Error then return result
end function
commandManager.registerCommand(Command.New({
    "name": "passwd",
    "description": "Change a user's password",
    "parameters": [
        Parameter.New({
            "name": "username",
            "required": true
        }),
        Parameter.New({
            "name": "password",
            "required": true
        })
    ],
    "callback": @passwdCommandHandler,
    "permissions": {
        "object": "computer",
        "privilege": "root"
    }
}))

exploitScanCommandHandler = function(params, extensionMediator)
    address = params.address
    port = params.port
    options = params.options

    metaxploitManager = extensionMediator.getExtension("metaxploitManager")
    objects = metaxploitManager.hack(address, port, options)

    if objects isa Error then return objects

    if not is_valid_ip(address) then
        libManager = extensionMediator.getExtension("libManager")
        lib = libManager.getCurrentLib("metaxploit")
        address = lib.data.ip
    else
        if is_lan_ip(address) then address = libManager.getCurrentLib("metaxploit").data.ip.public
        if port == null then return Error.New("Port is required")
        router = Router.New(address)
        if router isa Error then return router
        devices = router.devices()

        handleFindPort = function(device)
            for p in device.value
                if p.open and p.port == to_int(port) then return true
            end for
            return false
        end function
        device = find(devices, @handleFindPort)
        if device == null then return Error.New("Port is not open/found")
        localIp = device.key
        publicIp = address
        address = {
            "local": device.key,
            "public": publicIp
        }
    end if

    sessionManager = extensionMediator.getExtension("sessionManager")
    handleAddSessionObject = function(object)
        sessionManager.addSession(object, { "ip": address })
    end function
    forEach(objects, @handleAddSessionObject)
end function
commandManager.registerCommand(Command.New({
    "name": "exploitscan",
    "description": "Scan the network for exploits",
    "parameters": [
        Parameter.New({
            "name": "address",
            "required": true
        }),
        Parameter.New({
            "name": "port",
            "required": false
        }),
        Parameter.New({
            "name": "options",
            "required": false
        })
    ],
    "callback": @exploitScanCommandHandler
}))

exploitCommandHandler = function(params,extensionMediator)
    ipAddress = params.ipAddress
    address = params.address
    value = params.value
    options = params.options
    port = params.port
    metaxploitManager = extensionMediator.getExtension("metaxploitManager")
    objects = metaxploitManager.exploitKnown(ipAddress, port, address, value, options)

    if objects isa Error then return objects

    if not is_valid_ip(ipAddress) then
        libManager = extensionMediator.getExtension("libManager")
        lib = libManager.getCurrentLib("metaxploit")
        ipAddress = lib.data.ip
    else
        if is_lan_ip(ipAddress) then ipAddress = libManager.getCurrentLib("metaxploit").data.ip.public
        if port == null then return Error.New("Port is required")
        router = Router.New(ipAddress)
        if router isa Error then return router
        devices = router.devices()

        handleFindPort = function(device)
            for p in device.value
                if p.open and p.port == to_int(port) then return true
            end for
            return false
        end function
        device = find(devices, @handleFindPort)
        if device == null then return Error.New("Port is not open/found")
        localIp = device.key
        publicIp = ipAddress
        ipAddress = {
            "local": device.key,
            "public": publicIp
        }
    end if

    sessionManager = extensionMediator.getExtension("sessionManager")
    handleAddSessionObject = function(object)
        sessionManager.addSession(object, { "ip": ipAddress })
    end function
    forEach(objects, @handleAddSessionObject)
end function

commandManager.registerCommand(Command.New({
    "name": "exploit",
    "description": "Exploit a service with know vuln if local_lib then use any port",
    "parameters": [
        Parameter.New({
            "name": "ipAddress",
            "required": true
        }),
        Parameter.New({
            "name": "port",
            "required": true
        }),
        Parameter.New({
            "name": "address",
            "required": true
        }),
        Parameter.New({
            "name": "value",
            "required": true
        }),
        
        Parameter.New({
            "name": "options",
            "required": false
        })
    ],
    "callback": @exploitCommandHandler
}))

targetsCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    sessionManager = extensionMediator.getExtension("sessionManager")
    sessions = sessionManager.sessions

    viperUi.targets(sessions)
end function
commandManager.registerCommand(Command.New({
    "name": "targets",
    "description": "List all targets",
    "parameters": [],
    "callback": @targetsCommandHandler
}))

delTargetCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    sessions = sessionManager.sessions
    sessionIndex = params.sessionIndex
    count = params.count

    for i in range(sessionIndex, sessionIndex + count - 1)
        if i >= sessions.len then break
        session = sessionManager.removeSession(sessionIndex)
        if session isa Error then break
    end for
end function
commandManager.registerCommand(Command.New({
    "name": "deltarget",
    "description": "Delete a target",
    "parameters": [
        Parameter.New({
            "name": "sessionIndex",
            "required": true,
            "type": PARAMETER_TYPES.NUMBER
        }),
        Parameter.New({
            "name": "count",
            "required": false,
            "type": PARAMETER_TYPES.NUMBER,
            "default": 1
        })
    ],
    "callback": @delTargetCommandHandler
}))

useCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    sessions = sessionManager.sessions
    sessionIndex = params.sessionIndex

    session = sessionManager.setCurrentSession(sessionIndex)
    if session isa Error then return session
end function
commandManager.registerCommand(Command.New({
    "name": "use",
    "description": "Use a target",
    "parameters": [
        Parameter.New({
            "name": "sessionIndex",
            "required": true,
            "type": PARAMETER_TYPES.NUMBER
        })
    ],
    "callback": @useCommandHandler
}))

libsCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    libraryManager = extensionMediator.getExtension("libManager")
    libraries = libraryManager.libs
    currentLibs = libraryManager.currentLibs
    pivotLibs = libraryManager.pivotLibs

    libsHasLib = function(libs ,lib)
        handleSome = function(libsLib)
            if libsLib.value == lib then return true
        end function
        return some(libs, @handleSome)
    end function

    handleMapLibs = function(lib)
        return {
            "lib": lib,
            "current": libsHasLib(currentLibs, lib),
            "pivot": libsHasLib(pivotLibs, lib)
        }
    end function
    viperUi.libs(map(libraries, @handleMapLibs))
end function
commandManager.registerCommand(Command.New({
    "name": "libs",
    "description": "List all libraries",
    "parameters": [],
    "callback": @libsCommandHandler
}))

useLibCommandHandler = function(params, extensionMediator)
    libraryManager = extensionMediator.getExtension("libManager")
    libraries = libraryManager.libs
    libraryIndex = params.libraryIndex

    lib = libraryManager.getLib(libraryIndex)
    if lib isa Error then return lib

    library = libraryManager.setCurrentLib(lib)
    if library isa Error then return library
end function
commandManager.registerCommand(Command.New({
    "name": "uselib",
    "description": "Use a library",
    "parameters": [
        Parameter.New({
            "name": "libraryIndex",
            "required": true,
            "type": PARAMETER_TYPES.NUMBER
        })
    ],
    "callback": @useLibCommandHandler
}))

usePivotLibCommandHandler = function(params, extensionMediator)
    libraryManager = extensionMediator.getExtension("libManager")
    libraries = libraryManager.libs
    libraryIndex = params.libraryIndex

    lib = libraryManager.getLib(libraryIndex)
    if lib isa Error then return lib

    library = libraryManager.setPivotLib(lib)
    if library isa Error then return library
end function
commandManager.registerCommand(Command.New({
    "name": "usepivotlib",
    "description": "Use a library as a pivot",
    "parameters": [
        Parameter.New({
            "name": "libraryIndex",
            "required": true,
            "type": PARAMETER_TYPES.NUMBER
        })
    ],
    "callback": @usePivotLibCommandHandler
}))

addLibCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    libManager = extensionMediator.getExtension("libManager")

    session = sessionManager.currentSession
    handler = session.handler

    path = params.path
    jumpfileLocation = params.jumpfileLocation

    file = handler.getFile(path)
    if file isa Error then return file

    if jumpfileLocation == null then
        pivotSession = sessionManager.pivotSession
        pivotHandler = pivotSession.handler
       
        lib = include_lib(file.path())
        if lib == null then return Error.New("Failed to include library. "+lib)
        libManager.addLib(lib, { "path": file.path(), "ip": pivotHandler.ip })
    else
        jumpFile = handler.getFile(jumpfileLocation)
        if jumpFile isa Error then return jumpFile

        handler.executeFile(jumpfileLocation, "getLib " + file.path())
        if not get_custom_object.hasIndex("lib") then return Error.New("Failed to include library")
        lib = get_custom_object.lib
        if lib == null then return Error.New("Failed to include library")
        libManager.addLib(lib, { "path": file.path(), "ip": handler.ip })
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "addlib",
    "description": "Add a library",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        }),
        Parameter.New({
            "name": "jumpfileLocation",
            "required": false
        })
    ],
    "callback": @addLibCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

jumpFileCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    file = handler.file
    computer = handler.computer.computer
    path = params.path
    pathFile = path

    if(pathFile==".")then pathFile = handler.path
    fileSrc = computer.touch(pathFile, ".jumpfile.src") //create hidden file
    if(fileSrc!=1)then return fileSrc
    file = computer.File(pathFile+"/.jumpfile.src")
    if(typeof(file)!="file") then return print("jumpfile.src not found.")
    file.set_content(jumpfileText)

    result = handler.buildFile(file.path(), handler.getFile(path).path()) //compile the hidden code
    if result isa Error then return result

    //file.delete()  disabled to be more stealthy
end function
commandManager.registerCommand(Command.New({
    "name": "jumpfile",
    "description": "Create a jump file",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": false,
            "default": "."
        })
    ],
    "callback": @jumpFileCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

executeCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    path = params.path
    parameters = params.parameters

    return handler.executeFile(path, parameters)
end function
commandManager.registerCommand(Command.New({
    "name": "execute",
    "description": "Execute a file",
    "parameters": [
        Parameter.New({
            "name": "path",
            "required": true
        }),
        RestParameter.New({
            "name": "parameters",
            "required": false,
            "default": ""
        })
    ],
    "callback": @executeCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

sudoCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    user = params.user
    password = params.password
    jumpfileLocation = params.jumpfileLocation

    logIn = function (user, password)
        if jumpfileLocation == null then
            shell = get_shell(user, password)
            if shell == null then return Error.New("Failed to login")
        else
            isDict = "false"
            if password == "dict" then isDict = "true"
            jumpfile = handler.getFile(jumpfileLocation)
            if jumpfile isa Error then return jumpfile
            handler.executeFile(jumpfileLocation, "login " + user + " " + password + " " + isDict)
            if not get_custom_object.hasIndex("user") then return Error.New("Failed to login")
            shell = @get_custom_object.user
            if not (@shell isa get_shell.__isa) then return Error.New("Corrupt shell")
            if shell == null then return Error.New("Failed to login")
        end if

        return shell
    end function

    if password == "dict" then
        dictionaryManager = extensionMediator.getExtension("dictionaryManager")

        print "Trying dictionary attack"

        if jumpfileLocation != null then
            get_custom_object.passwords = [] + dictionaryManager.passwords
            shell = logIn(user, "dict")
        else
            password = dictionaryManager.get()

            while not password isa Error 
                shell = logIn(user, password)
                if not shell isa Error then break
                password = dictionaryManager.get()
            end while
        end if
    else
        shell = logIn(user, password)
    end if

    if shell isa Error then return shell

    session = sessionManager.addSession(shell, { "ip": handler.ip })
    sessionManager.setCurrentSession(sessionManager.getSessionIndex(session))

    return "Logged in"
end function
commandManager.registerCommand(Command.New({
    "name": "sudo",
    "description": "Login to a shell (you can pass dict as the password to use the dictionary attack)",
    "parameters": [
        Parameter.New({
            "name": "user",
            "required": true
        }),
        OptionsParameter.New({
            "name": "password",
            "required": true,
            "options": {
                "password": null,
                "dict": "dict"
            }
        }),
        Parameter.New({
            "name": "jumpfileLocation",
            "required": false
        })
    ],
    "callback": @sudoCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))
clsCommandHandler = function(params, extensionMediator)
    return clear_screen
end function
commandManager.registerCommand(Command.New({
    "name": "cls",
    "description": "Clear the screen without banner.",
    "parameters": [],
    "callback": @clsCommandHandler
}))

clearCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    libManager = extensionMediator.getExtension("libManager")

    clear_screen()
    viperUi.init() 
    currentLibs = libManager.currentLibs
    listCurrentLibs = []
    for lib in currentLibs
        listCurrentLibs.push(lib.value)
    end for
    viperUi.currentLibs(listCurrentLibs)
end function
commandManager.registerCommand(Command.New({
    "name": "clear",
    "description": "Clear the screen",
    "parameters": [],
    "callback": @clearCommandHandler
}))

termCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler

    handler.activate()
end function
commandManager.registerCommand(Command.New({
    "name": "term",
    "description": "Go active shell",
    "parameters": [],
    "callback": @termCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

getCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    pivotSession = sessionManager.pivotSession
    pivotHandler = pivotSession.handler
    currentSession = sessionManager.currentSession
    currentHandler = currentSession.handler

    fromPath = params.fromPath
    toPath = params.toPath

    result = pivotHandler.getFileFrom(toPath, fromPath, currentHandler)
    if result isa Error then return result
end function
commandManager.registerCommand(Command.New({
    "name": "get",
    "description": "Get a file from the pivot",
    "parameters": [
        Parameter.New({
            "name": "fromPath",
            "required": true
        }),
        Parameter.New({
            "name": "toPath",
            "required": false,
            "default": "."
        })
    ],
    "callback": @getCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

putCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    pivotSession = sessionManager.pivotSession
    pivotHandler = pivotSession.handler
    currentSession = sessionManager.currentSession
    currentHandler = currentSession.handler

    fromPath = params.fromPath
    toPath = params.toPath

    result = pivotHandler.putFileTo(fromPath, toPath, currentHandler)
    if result isa Error then return result
end function
commandManager.registerCommand(Command.New({
    "name": "put",
    "description": "Put a file to the pivot",
    "parameters": [
        Parameter.New({
            "name": "fromPath",
            "required": true
        }),
        Parameter.New({
            "name": "toPath",
            "required": false,
            "default": "."
        })
    ],
    "callback": @putCommandHandler,
    "permissions": {
        "object": "shell"
    }
}))

nukeCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    currentSession = sessionManager.currentSession
    currentHandler = currentSession.handler

    fileObject = currentHandler.current.file
    allFiles = libs.allFiles(fileObject)
    for file in allFiles
        if(not file.has_permission("w"))then continue
        file.delete
        print(file.path+" deleted.")
    end for

end function
commandManager.registerCommand(Command.New({
    "name": "nuke",
    "description": "Delete all files using any Object (best with root access)",
    "parameters": [],
    "callback": @nukeCommandHandler,
    "permissions": {
        "privilege": "guest"
    }
}))

psCommandHabdler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    sessionManager = extensionMediator.getExtension("sessionManager")
    currentSession = sessionManager.currentSession
    currentHandler = currentSession.handler

    processes = currentHandler.processes()

    viperUi.ps(processes)
end function
commandManager.registerCommand(Command.New({
    "name": "ps",
    "description": "List all processes",
    "parameters": [],
    "callback": @psCommandHabdler,
    "permissions": {
        "object": "computer"
    }
}))

killCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    currentSession = sessionManager.currentSession
    currentHandler = currentSession.handler

    pid = params.pid

    if pid == "all" then
        processes = currentHandler.processes()
        handleKillProcess = function(process)
            currentHandler.closeProcess(process.PID)
        end function
        forEach(processes, @handleKillProcess)
    else
        result = currentHandler.closeProcess(pid)
        if result isa Error then return result
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "kill",
    "description": "Kill a process",
    "parameters": [
        OptionsParameter.New({
            "name": "pid",
            "required": true,
            "options": {
                "pid": null,
                "all": "all"
            }
        })
    ],
    "callback": @killCommandHandler,
    "permissions": {
        "object": "computer"
    }
}))

echoCommandHandler = function(params, extensionMediator)
    text = params.text
    return text
end function
commandManager.registerCommand(Command.New({
    "name": "echo",
    "description": "Print text",
    "parameters": [
        RestParameter.New({
            "name": "text",
            "required": false,
            "default": ""
        })
    ],
    "callback": @echoCommandHandler
}))

returnCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    sessionManager.setCurrentSession(sessionManager.getSessionIndex(sessionManager.pivotSession))
end function
commandManager.registerCommand(Command.New({
    "name": "return",
    "description": "Return to the pivot",
    "parameters": [],
    "callback": @returnCommandHandler
}))

backCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    count = params.count
    if count == null then return Error.New("Invalid count")
    for i in range(0, count - 1)
        sessionManager.goBack()
    end for
end function
commandManager.registerCommand(Command.New({
    "name": "back",
    "description": "back out of shell",
    "parameters": [
        Parameter.New({
            "name": "count",
            "required": false,
            "type": PARAMETER_TYPES.NUMBER,
            "default": 1
        })
    ],
    "callback": @backCommandHandler
}))

exitCommandHandler = function(params, extensionMediator)
    exit()
end function
commandManager.registerCommand(Command.New({
    "name": "exit",
    "description": "Exit the program",
    "parameters": [],
    "callback": @exitCommandHandler
}))
commandManager.addAlias("mx", "put /lib/metaxploit.so")
commandManager.addAlias("root", "sudo root dict jumpfile")
commandManager.addAlias("addmx", "addlib metaxploit.so jumpfile")
addAliasCommandHandler = function(params, extensionMediator)
    commandManager = extensionMediator.getExtension("commandManager")
    alias = params.alias
    command = params.command

    commandManager.addAlias(alias, command)
end function
commandManager.registerCommand(Command.New({
    "name": "addalias",
    "description": "Add an alias",
    "parameters": [
        Parameter.New({
            "name": "alias",
            "required": true
        }),
        RestParameter.New({
            "name": "command",
            "required": true
        })
    ],
    "callback": @addAliasCommandHandler
}))

nsLookupCommandHandler = function(params, extensionMediator)
    address = params.address
    result = nslookup(address)
    if result == "Not Found" then return Error.New("Not Found")
    return result
end function
commandManager.registerCommand(Command.New({
    "name": "nslookup",
    "description": "Lookup an ip address",
    "parameters": [
        Parameter.New({
            "name": "address",
            "required": true
        })
    ],
    "callback": @nsLookupCommandHandler
}))

secureCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    type = params.type

    if type == "home" then
        files = handler.getFile("/").children
        handleSecureFile = function(file)
            if file.name == "Terminal.exe" then return
            if file.name == "home" then return
            if file.name == "usr"  then
                if not file.hasChild("bin") then return
                forEach(file.child("bin").children, @handleSecureFile)
                return
            end if
            if file.name == "sudo" then return
            if file.name == "bin" then 
                forEach(file.children, @handleSecureFile)
                return
            end if
            file.setPermissions("o-rwx", true)
            file.setPermissions("g-rwx", true)
            file.setPermissions("u-rwx", true)
        end function
        forEach(files, @handleSecureFile)
    else
        files = handler.getFile("/").children
        handleSecureFile = function(file)
            file.setPermissions("o-rwx", true)
            file.setPermissions("g-rwx", true)
            file.setPermissions("u-rwx", true)
        end function
        forEach(files, @handleSecureFile)
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "secure",
    "description": "Secure the system",
    "parameters": [
        OptionsParameter.New({
            "name": "type",
            "required": true,
            "options": {
                "home": "home",
                "server": "server"
            }
        }),
    ],
    "callback": @secureCommandHandler,
    "permissions": {
        "object": "file",
        "privilege": "root"
    }
}))

msfvenomCommandHandler = function(params, extensionMediator)
    ip = params.ip
    port = params.port
    
    metaxploitManager = extensionMediator.getExtension("metaxploitManager")
    return metaxploitManager.connectRShell(ip, port)
end function
commandManager.registerCommand(Command.New({
    "name": "msfvenom",
    "description": "Create a payload",
    "parameters": [
        Parameter.New({
            "name": "ip",
            "required": true
        }),
        Parameter.New({
            "name": "port",
            "required": false,
            "default": 1222,
            "type": PARAMETER_TYPES.NUMBER
        })
    ],
    "callback": @msfvenomCommandHandler
}))

msfconsoleCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    metaxploitManager = extensionMediator.getExtension("metaxploitManager")
    shells = metaxploitManager.rShellList()
    if shells isa Error then return shells
    if shells.len() == 0 then return Error.New("No shells available")
    handleShellsToSession = function (shell)
        return Session.New(shell, {})
    end function
    viperUi.msfConsole(map(shells, @handleShellsToSession))
    input = user_input(viperUi.msfConsoleInput)
    inputNumber = to_int(input)
    if inputNumber >= shells.len() or typeof(inputNumber) == "string" or inputNumber < 0 then return Error.New("Invalid input") 
    session = Session.New(shells[inputNumber], {})
    sessionManager = extensionMediator.getExtension("sessionManager")
    sessionManager.addSession(session)
    sessionManager.setCurrentSession(sessionManager.getSessionIndex(session))
end function
commandManager.registerCommand(Command.New({
    "name": "msfconsole",
    "description": "Starts a listiner for incomming rshells.",
    "parameters": [],
    "callback": @msfconsoleCommandHandler
}))

adduserCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    user = params.user
    password = params.password

    res = handler.addUser(user, password)
    if res isa Error then return res
end function
commandManager.registerCommand(Command.New({
    "name": "adduser",
    "description": "Adds a user to the computer.",
    "parameters": [
        Parameter.New({
            "name": "user",
            "required": true
        }),
        Parameter.New({
            "name": "password",
            "required": true
        })
    ],
    "callback": @adduserCommandHandler,
    "permissions": {
        "object": "computer",
        "privilege": "root"
    }
}))

deluserCommandHandler = function(params, extensionMediator)
    sessionManager = extensionMediator.getExtension("sessionManager")
    session = sessionManager.currentSession
    handler = session.handler
    user = params.user

    res = handler.deleteUser(user)
    if res isa Error then return res
end function
commandManager.registerCommand(Command.New({
    "name": "deluser",
    "description": "Deletes a user from the computer.",
    "parameters": [
        Parameter.New({
            "name": "user",
            "required": true
        }),
    ],
    "callback": @deluserCommandHandler,
    "permissions": {
        "object": "computer",
        "privilege": "root"
    }
}))

findlibCommandHandler = function(params, extensionMediator)
    type = params.type
    version = params.version

    validTypes = ["kernel_router", "ssh", "ftp", "http", "rshell", "smtp", "employees", "cam", "repository"]

    if validTypes.hasIndex(type) == null then return Error.New("Invalid type")

    found = false
    while found == false
        router = Router.New(randomIp())
        if router isa Error then continue
        print "Scanning for " + type + " " + version + " on " + router.ip.public

        devices = router.devices()
        handleFindLib = function(device)
            if device == null then return
            for port in device
                if port.type == type and port.version == version then
                    outer.found = outer.router.ip.public
                    return
                end if
            end for
        end function
        for device in devices
            if device == null then return
            handleFindLib(device.value)
        end for
    end while

    print "Found " + type + " " + version + " on " + found
end function
commandManager.registerCommand(Command.New({
    "name": "findlib",
    "description": "Finds a library",
    "parameters": [
        Parameter.New({
            "name": "type",
            "required": true
        }),
        Parameter.New({
            "name": "version",
            "required": false,
            "default": "1.0.0"
        })
    ],
    "callback": @findlibCommandHandler
}))

historyCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    commandManager = extensionMediator.getExtension("commandManager")
    id = params.id

    if id != null then
        id = id + 1
        if commandManager.len < 0 or id >= commandManager.history.len then return Error.New("Invalid id")
        command = commandManager.history[id]
        print "will execute: " + command[0].name + " " + command[1] + " " + params.newParams
        commandManager.executeCommand(command[0].name + " " + command[1] + " " + params.newParams)
    else
        viperUi.history(commandManager.history)
    end if
end function
commandManager.registerCommand(Command.New({
    "name": "history",
    "description": "Show command history",
    "parameters": [
        Parameter.New({
            "name": "id",
            "required": false,
            "type": PARAMETER_TYPES.NUMBER
        }),
        RestParameter.New({
            "name": "newParams",
            "required": false,
            "default": ""
        })
    ],
    "callback": @historyCommandHandler
}))

helpCommandHandler = function(params, extensionMediator)
    viperUi = extensionMediator.getExtension("viperUi")
    commandManager = extensionMediator.getExtension("commandManager")
    commandName = params.commandName

    if commandName != null then
        command = commandManager.getCommand(commandName)
        if command isa Error then return command
        hasPermission = commandManager.checkPermissions(command)
        hasPermission = not(hasPermission isa Error)
        result = {
            "name": command.name,
            "description": command.description,
            "parameters": command.parameters,
            "hasPermissions": hasPermission
        }
        viperUi.helpSingle(result)
        return
    end if

    commandsList = []
    for command in commandManager.commands
        command = command.value
        hasPermissions = commandManager.checkPermissions(command)
        hasPermissions = not(hasPermissions isa Error)
        result = {
            "name": command.name,
            "description": command.description,
            "parameters": command.parameters,
            "hasPermissions": hasPermissions
        }
        commandsList.push(result)
    end for
    mxCommand = {
        "name": "mx",
        "description": "upload metaxploit to victim",
        "parameters": "",
        "hasPermissions": "guest"
    }
    addmxCommand = {
        "name": "addmx",
        "description": "add uploaded mx library",
        "parameters": "",
        "hasPermissions": "guest"
    }
    rootCommand = {
        "name": "root",
        "description": "run dictionary attack on victim computer using jumpfile",
        "parameters": "",
        "hasPermissions": "guest"
    }
    commandsList.push(mxCommand)
    commandsList.push(rootCommand)
    commandsList.push(addmxCommand)
    viperUi.help(commandsList)
end function
commandManager.registerCommand(Command.New({
    "name": "help",
    "description": "Show help",
    "parameters": [
        Parameter.New({
            "name": "commandName",
            "required": false
        })
    ],
    "callback": @helpCommandHandler
}))